実行前考察
-----------------------------------------------
printfする直前における模式図を下に示す。

#xp[0] -> x[3] -> "first"
xp[1] -> x[2] -> "point"
xp[2] -> x[1] -> "new"
xp[3] -> x[0] -> "enter"

ただし、A -> Bは、AがBのポインタであることを示している。
また、#はxppの位置である。

最初のprintfでは、++xppにより、下のような構造になる。

xp[0] -> x[3] -> "first"
#xp[1] -> x[2] -> "point"
xp[2] -> x[1] -> "new"
xp[3] -> x[0] -> "enter"

したがって、"point"が出力される。

次に、--*++xpp、すなわち xpp = xpp + 1, *xpp = *xpp - 1 を順に計算すると、下のようになる。

         x[3] -> "first"
xp[0] -> x[2] -> "point"
xp[1] -> x[1] -> "new"
#xp[2] -> x[0] -> "enter"
xp[3] -> x[-1] -> ""

したがって、最後の引数+3の操作により"first"が出力される。

その次のprintfでは、値が変わることはない。xpp[-2] = *(xpp -2) =x[-2]であるから、+3したx[1]、すなわち"new"が出力される。

最後に、xpp[-1] = xpp[-1] - 1 より下のようになる。

         x[3] -> "first"
         x[2] -> "point"
xp[0] -> x[1] -> "new"
xp[1] -> x[0] -> "enter"
#xp[2] -> x[-1] -> ""
xp[3] -> x[-2] -> ""

よって、最後に引数+1をして、"enter"が出力される。

------------------------------------------------
実行→pointerstew

まず、出力引数の最後の+3とかの意味を、勘違いしていました。
要するに、**xppが、文字列の一番最初の文字が格納されている場所のことを指しているので、たとえば二番目の出力では、最後の+3がないと"enter"が出力されるが、最初のeの位置から3つ値が足された位置からの文字列リテラル"er"が出力されるというわけです。
あと、同じところで、*xpp = *xpp -1のときに、なぜかxのほかの値も全部動かしてしまったのですが、よく考えてみればxp[2]とxp[3]の値が同じ(x[0])でも全く問題ありませんでした。正しくは


xp[0] -> x[3] -> "first"
xp[1] -> x[2] -> "point"
#xp[2] -> x[0] -> "enter"
xp[3] -> x[0] -> "enter"
         x[1] -> "new"
でした。

また、三回目の出力の際、xpp[-2] = x[-2]などという、型を無視した等式を立てていました。xpp[-2] = *(xpp -2) = xp[0] = &x[3]ですね。最後に+3をしているので、"st"が出力されます。

四回目のディクリメントもひどいですね。
正しくは以下。理由は同上


xp[0] -> x[3] -> "first"
xp[1] -> x[1] -> "new"
#xp[2] -> x[0] -> "enter"
xp[3] -> x[0] -> "enter"

よって、最後の+1により、"ew"が出力されます。